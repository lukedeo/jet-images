#!/usr/bin/env python

'''
batch_submit.py -- a script to submit batched 
jet-image event generation jobs.

Author: Luke de Oliveira
'''

import argparse
import sys
import os
import datetime
from subprocess import Popen, PIPE, STDOUT
import logging

LOGGER_PREFIX = ' %s'
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def log(msg):
    logger.info(LOGGER_PREFIX % msg)

####### CHANGE THESE PARAMETERS ###########

BOSON_MASS = 800

PT_HAT_MIN, PT_HAT_MAX = [200, 400]

###########################################

def simulation_dir():
    '''
    Returns the path to all of the simulation code.

    Put in your /path/to/jet-simulations
    '''
    if os.environ['USER'] == 'lukedeo':
        return '/u/at/lukedeo/jet-simulations'
    elif os.environ['USER'] == 'bpn7':
        # -- @bnachman you should change this to your directory.
        return '/nfs/slac/g/atlas/u01/users/bnachman/SLAC_pythia/Reclustering'
    else:
        raise ValueError('Invalid user!')


def generate_script(d):
    '''
    Generates a boilerplate script of the form:

    cd /path/to/jet-simulations
    source ./setup.sh
    ./event-gen/event-gen --OutFile test.root --Proc 3 --NEvents 100 --pThatMin 200 --pThatMax 400 --BosonMass 800

    where the flags are filled in by `d`

    `d` should have the following keys:
        * file
        * process
        * events
        * pthatmin
        * pthatmax
        * bosonmass

    '''
    return 'cd {}\n'.format(simulation_dir()) + 'source ./setup.sh\n./event-gen/event-gen --OutFile {file} \
    --Proc {process} --NEvents {events} --pThatMin {pthatmin} --pThatMax {pthatmax} --BosonMass {bosonmass}'.format(**d)

def invoke_bsub(name, queue, log):
    '''
    Starts up bsub, and hangs in a state where a script can be piped in.
    '''
    return 'bsub -J "%s" -o %s -q %s' % (
            name, log, queue
        )


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('--jobs', type=int,
        help='Number of jobs to run', required=True)

    parser.add_argument('--events', type=int,
        help='Number of events', required=True)

    parser.add_argument('--output-dir', type=str, default='./files',
        help='path to directory where data files should be written')

    parser.add_argument('--file-prefix', type=str, default='GENERATED',
        help='prefix written to the start of all output files.')

    parser.add_argument('--log-dir', type=str, default='./logs',
        help='Path to directory to write the logs')
    
    parser.add_argument('--process', type=str, default='qcd',
        help='which process?', choices=['qcd', 'wprime'])

    process_dict = {'qcd' : 4, 'wprime' : 2}

    args = parser.parse_args()

    log('Determining output directories.')

    # -- get the simulation directory
    work_dir = simulation_dir()

    # -- create a timestamped subdir
    subdir = datetime.datetime.now().strftime('%b%d-%H%M%S')

    # -- make the logging directory
    if not os.path.exists(os.path.join(args.log_dir, subdir)):
        os.makedirs(os.path.join(args.log_dir, subdir))

    log('Will write logs to {}'.format(os.path.join(args.log_dir, subdir)))
    
    # -- make the job output directory
    scratch_space = os.path.join(args.output_dir, subdir)
    if not os.path.exists(os.path.join(args.output_dir, subdir)):
        os.makedirs(scratch_space)

    log('Will write samples to {}'.format(scratch_space))

    log('Script submitted for {} generation.'.format(args.process))
    
    log('Generating {} x {} = {} events.'.format(
            args.jobs, args.events, args.jobs * args.events
        )
    )
    # -- which process?
    process_code = process_dict[args.process]


    for job in xrange(args.jobs):
        log('Launching job %s of %s...' % (job + 1, args.jobs))

        # -- dump the bsub output into a nice format
        log_file = os.path.join(args.log_dir, subdir, 'log_job_{}.log'.format(job))

        # -- format the output files with all the relevant kinematic shit
        output_file = '%s_process_%s_bosonmass%s_pthat%s-%s_nevents%s_job%s.root' % (
                args.file_prefix, 
                args.process, 
                BOSON_MASS, 
                PT_HAT_MIN, 
                PT_HAT_MAX, 
                args.events,
                job
            )

        # -- this formats the autogenerated script
        job_params = {
            'file' : os.path.join(scratch_space, output_file), 
            'process' : process_code, 
            'events' : args.events, 
            'pthatmin' : PT_HAT_MIN, 
            'pthatmax' : PT_HAT_MAX, 
            'bosonmass': BOSON_MASS
        }

        # -- catalogue where shit is going
        log('Job log is {}.'.format(log_file))
        log('Job output is {}.'.format(os.path.join(scratch_space, output_file)))

        # -- wrap the call to the batch system
        cmd = invoke_bsub('j%sof%s' % (job + 1, args.jobs), 'medium', log_file)

        log('Call is: {}'.format(cmd))

        # -- Open a process...
        job_out = Popen(cmd.split(), stdin=PIPE, stdout=PIPE, stderr=STDOUT)

        # -- ...and feed it the autogen script.
        _ = job_out.communicate(input=generate_script(job_params))
        log('Success.')


